.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Liberty::Parser 3pm"
.TH Liberty::Parser 3pm "2010-03-28" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Liberty::Parser \- Parser for Synopsys Liberty(.lib).
.SH "VERSION"
.IX Header "VERSION"
Version 0.04
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Liberty::Parser;
\&  my $parser = new Liberty::Parser;
\&  my $library_group  = $parser\->read_file("standard_cell.lib");
\&
\&  my $lib_name = $parser\->get_group_name($library_group);
\&  print "Library Name: $lib_name\en";
\&  print $parser\->get_attr_with_value($library_group,"nom_temperature");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Liberty::Parser is indeed a Perl wrapper for a Liberty Parser which is written in C from
Synopsys's Open Liberty Project.
.PP
Liberty::Parser harnesses Open Libety Project with Perl through the help of \s-1SWIG \s0(www.swig.org)
and implemented many handy functions to make information extracting from Liberty can
be easily accomplished.
.PP
To get Liberty::Parser work, you have to download liberty_parse from Open Liberty Project.
Compile the C source into linked library then put the linked library at somewhere it can
be found through the environment variable \s-1LD_LIBRARY_PATH.\s0 Please follow the guide in the
\&\s-1INSTALLATION\s0 section of \s-1README.\s0
.SH "BASIC FUNTIONS"
.IX Header "BASIC FUNTIONS"
.SS "new"
.IX Subsection "new"
To new a Liberty::Parser object.
.SS "read_file"
.IX Subsection "read_file"
read_file :*group : (string filename)
.PP
Read the liberty format file and return a group handle.
.SS "locate_cell"
.IX Subsection "locate_cell"
locate_cell : *group : (*group, string cell_name)
.PP
Return the handle of group type `cell'.
.SS "locate_port"
.IX Subsection "locate_port"
locate_port : *group : (*group, string port_name)
Return the handle of group type `port'.
.SS "locate_group"
.IX Subsection "locate_group"
locate_group : *group : (*group, string group_name)
Return the handle of group type `cell'.
.SS "locate_group_by_type"
.IX Subsection "locate_group_by_type"
.Vb 1
\&  $parser\->locate_group_by_type($g, $type_name);
.Ve
.SS "locate_cell_arc"
.IX Subsection "locate_cell_arc"
.Vb 1
\&  $parser\->locate_cell_arc($g, $type_name);
.Ve
.SS "get_group_name"
.IX Subsection "get_group_name"
get_group_name : string : (*group)
Return the group name while input a group handle.
Example:
.PP
.Vb 1
\&  print $p\->get_group_name($g_func);
.Ve
.SS "get_group_names"
.IX Subsection "get_group_names"
get_group_names : array : (*group G)
Return the handle of group type `cell'. Example:
.PP
.Vb 2
\& my @j = $p\->get_group_names ($f_cell);
\& dump_array(\e@j);
.Ve
.SS "get_groups_by_type"
.IX Subsection "get_groups_by_type"
Return the handle of group type `cell'. Example:
.PP
.Vb 1
\& my @j = $p\->get_groups_by_type($group, $type_name);
.Ve
.SS "get_group_type"
.IX Subsection "get_group_type"
get_group_type : string : (*group G)
Return the type name of the group G. Example:
.PP
.Vb 1
\& print $p\->get_group_type($g);
.Ve
.SS "get_attr_name"
.IX Subsection "get_attr_name"
get_attr_name : string : (*attr A)
Return the attribute name while input a attribute handle.
.SS "get_attr_type"
.IX Subsection "get_attr_type"
Return the attribute type while input a attribute handle.
.PP
.Vb 1
\& get_attr_type : string : (*attr A)
.Ve
.SS "get_value_type"
.IX Subsection "get_value_type"
get_value_type : string : (*attr)
.PP
Return the value type of attribute A.
.SS "get_simple_attr_value"
.IX Subsection "get_simple_attr_value"
.Vb 1
\&  $parser\->get_simple_attr_value($group, $attr_name);
.Ve
.SS "get_attr_with_value"
.IX Subsection "get_attr_with_value"
get_attr_with_value : string : (*group, string attr_name)
Return a string with attriubte name and attribute value.
.SS "get_lookup_table_index_1"
.IX Subsection "get_lookup_table_index_1"
.Vb 5
\& input1: 
\& input2: 
\& return: 2D array
\& Ex:
\& $parser\->get_lookup_table_index($group);
.Ve
.SS "get_lookup_table_index_2"
.IX Subsection "get_lookup_table_index_2"
.Vb 5
\& input1: 
\& input2: 
\& return: 2D array
\& Ex:
\& $parser\->get_lookup_table_index_2($group);
.Ve
.SS "get_lookup_table"
.IX Subsection "get_lookup_table"
.Vb 5
\& input1: 
\& input2: 
\& return: 2D array
\& Ex:
\& $parser\->get_lookup_table($group);
.Ve
.SS "get_lookup_table_center"
.IX Subsection "get_lookup_table_center"
.Vb 5
\& input1: timing type group
\& input2: cell_rise, cell_fall...
\& return: number
\& Ex:
\& $rise = $parser\->get_lookup_table_array($timing_group, "cell_rise");
.Ve
.SS "get_lookup_table_center"
.IX Subsection "get_lookup_table_center"
.Vb 5
\& input1: timing type group
\& input2: cell_rise, cell_fall...
\& return: number
\& Ex:
\& $rise = $parser\->get_lookup_table_center($timing_group, "cell_rise");
.Ve
.SS "check_related_pin"
.IX Subsection "check_related_pin"
.Vb 5
\& input1: a reference to timing group
\& input2: pin name as string
\& return: 1 or 0
\& Ex:
\& $parser\->check_related_pin($timing_group, $pin_name);
.Ve
.SS "check_group_type"
.IX Subsection "check_group_type"
.Vb 4
\& input: pin, timing, cell_rise, cell_fall, ...
\& return: 1 or 0
\& Ex:
\& $parser\->check_group_type($group, "pin");
.Ve
.SS "print_attrs"
.IX Subsection "print_attrs"
print_attrs : void : (*group G)
Print all attributes of a group G.
.SS "print_timing_arc"
.IX Subsection "print_timing_arc"
Print timing arc of group G(must be a pin type group.) Example:
.PP
.Vb 1
\& $parser\->print_timing_arc($pin_group);
.Ve
.SS "print_groups"
.IX Subsection "print_groups"
print_groups : void : (*group G)
Print groups contained in group G in format \*(L"type:name\*(R". Example:
.PP
.Vb 1
\& $p\->print_groups($g);
.Ve
.SS "get_cell_delay"
.IX Subsection "get_cell_delay"
.Vb 1
\& $parser\->get_cell_delay($pin_group);
.Ve
.SS "is_var"
.IX Subsection "is_var"
is_var : 
Return the handle of group type `cell'.
.SH "COMPLEX FUNTIONS"
.IX Header "COMPLEX FUNTIONS"
.SS "extract_group"
.IX Subsection "extract_group"
extract_group : string : (*group G, int indent)
Return the whole content of the group G.
.SS "extract_group_1"
.IX Subsection "extract_group_1"
extract_group_1 : string : (*group G, int indent)
Return the \*(L"surface\*(R" of the group G.
.SS "all_attrs"
.IX Subsection "all_attrs"
all_attrs : string : (*group G, int indent)
Return the handle of group type `cell'.
.SH "PRIMITIVE FUNCTIONS"
.IX Header "PRIMITIVE FUNCTIONS"
.Vb 10
\&  lib_PICreateGroup
\&  lib_GroupCreateAttr
\&  lib_AttrGetAttrType
\&  lib_AttrGetName
\&  lib_ComplexAttrAddInt32Value
\&  lib_ComplexAttrAddStringValue
\&  lib_ComplexAttrAddBooleanValue
\&  lib_ComplexAttrAddFloat64Value
\&  lib_ComplexAttrAddExprValue
\&  lib_ComplexAttrGetValues
\&  lib_IterNextComplex
\&  lib_ComplexValGetValueType
\&  lib_ComplexValGetInt32Value
\&  lib_ComplexValGetFloat64Value
\&  lib_ComplexValGetStringValue
\&  lib_ComplexValGetBooleanValue
\&  lib_ComplexValGetExprValue
\&  lib_SimpleAttrGetValueType
\&  lib_SimpleAttrGetInt32Value
\&  lib_SimpleAttrGetFloat64Value
\&  lib_SimpleAttrGetStringValue
\&  lib_SimpleAttrGetBooleanValue
\&  lib_SimpleAttrGetExprValue
\&  lib_SimpleAttrSetInt32Value
\&  lib_SimpleAttrSetBooleanValue
\&  lib_SimpleAttrSetFloat64Value
\&  lib_SimpleAttrSetStringValue
\&  lib_SimpleAttrSetExprValue
\&  lib_SimpleAttrGetIsVar
\&  lib_SimpleAttrSetIsVar
\&  lib_ExprDestroy
\&  lib_CreateExpr
\&  lib_CreateBooleanValExpr
\&  lib_CreateDoubleValExpr
\&  lib_CreateStringValExpr
\&  lib_CreateIntValExpr
\&  lib_CreateBinaryOpExpr
\&  lib_CreateUnaryOpExpr
\&  lib_ExprToString
\&  lib_ExprGetType
\&  lib_ValExprGetValueType
\&  lib_IntValExprGetInt
\&  lib_DoubleValExprGetDouble
\&  lib_BooleanValExprGetBoolean
\&  lib_StringValExprGetString
\&  lib_OpExprGetLeftExpr
\&  lib_OpExprGetRightExpr
\&  lib_GroupCreateDefine
\&  lib_DefineGetInfo
\&  lib_DefineGetName
\&  lib_DefineGetAllowedGroupName
\&  lib_DefineGetValueType
\&  lib_GroupCreateGroup
\&  lib_GroupGetGroupType
\&  lib_GroupGetComment
\&  lib_GroupSetComment
\&  lib_AttrGetComment
\&  lib_AttrSetComment
\&  lib_DefineGetComment
\&  lib_DefineSetComment
\&  lib_GroupAddName
\&  lib_GroupDeleteName
\&  lib_PIFindGroupByName
\&  lib_GroupFindGroupByName
\&  lib_GroupFindAttrByName
\&  lib_GroupFindDefineByName
\&  lib_PIFindDefineByName
\&  lib_PIGetGroups
\&  lib_GroupGetGroups
\&  lib_GroupGetNames
\&  lib_GroupGetAttrs
\&  lib_GroupGetDefines
\&  lib_IterNextGroup
\&  lib_IterNextName
\&  lib_IterNextAttr
\&  lib_IterNextDefine
\&  lib_IterQuit
\&  lib_ObjectDelete
\&  lib_PIGetErrorText
\&  lib_PIGetNullId
\&  lib_PIInit
\&  lib_PIQuit
\&  lib_ObjectGetObjectType
\&  lib_ObjectGetOwner
\&  lib_ObjectIsNull
\&  lib_ObjectIsSame
\&  lib_ObjectIsUsable
\&  lib_ObjectSetFileName
\&  lib_ObjectSetLineNo
\&  lib_ObjectGetLineNo
\&  lib_ObjectGetFileName
\&  lib_ReadLibertyFile
\&  lib_WriteLibertyFile
\&  lib_CheckLibertyLibrary
\&  lib_PIGetTraceMode
\&  lib_PIUnSetTraceMode
\&  lib_PISetTraceMode
\&  lib_PISetDebugMode
\&  lib_PIUnSetDebugMode
\&  lib_PIGetDebugMode
\&  lib_PISetNocheckMode
\&  lib_PIUnSetNocheckMode
\&  lib_PIGetNocheckMode
\&  lib_GroupMoveAfter
\&  lib_GroupMoveBefore
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.SS "OpenSource Liberty Project"
.IX Subsection "OpenSource Liberty Project"
http://www.opensourceliberty.org
.SH "AUTHOR"
.IX Header "AUTHOR"
yorkwu, <yorkwuo@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.5 or,
at your option, any later version of Perl 5 you may have available.
